From 532c08d4b9a51c35bf5a17c605913d5b59871448 Mon Sep 17 00:00:00 2001
From: root <root@testpaper.20191124-2>
Date: Thu, 28 Nov 2019 17:51:32 +0000
Subject: [PATCH 3/5] reduce villiger path finding period

---
 .../net/minecraft/server/BehaviorController.java   | 236 +++++++++++++++++++++
 .../net/minecraft/server/BehaviorFindPosition.java |  66 ++++++
 2 files changed, 302 insertions(+)
 create mode 100644 src/main/java/net/minecraft/server/BehaviorController.java
 create mode 100644 src/main/java/net/minecraft/server/BehaviorFindPosition.java

diff --git a/src/main/java/net/minecraft/server/BehaviorController.java b/src/main/java/net/minecraft/server/BehaviorController.java
new file mode 100644
index 000000000..ac1b4edad
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BehaviorController.java
@@ -0,0 +1,236 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.datafixers.Dynamic;
+import com.mojang.datafixers.types.DynamicOps;
+import com.mojang.datafixers.util.Pair;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.Map.Entry;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.server.Behavior.Status;
+
+public class BehaviorController<E extends EntityLiving> implements MinecraftSerializable {
+    private final Map<MemoryModuleType<?>, Optional<?>> memories = Maps.newHashMap();
+    private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
+    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap();
+    private Schedule schedule;
+    private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> e;
+    private Set<Activity> f;
+    private final Set<Activity> g;
+    private Activity h;
+    private long i;
+
+    public <T> BehaviorController(Collection<MemoryModuleType<?>> var0, Collection<SensorType<? extends Sensor<? super E>>> var1, Dynamic<T> var2) {
+        this.schedule = Schedule.EMPTY;
+        this.e = Maps.newHashMap();
+        this.f = Sets.newHashSet();
+        this.g = Sets.newHashSet();
+        this.h = Activity.IDLE;
+        this.i = -9999L;
+        var0.forEach((var0x) -> {
+            Optional var10000 = (Optional)this.memories.put(var0x, Optional.empty());
+        });
+        var1.forEach((var0x) -> {
+            Sensor var10000 = (Sensor)this.sensors.put(var0x, var0x.a());
+        });
+        this.sensors.values().forEach((var0x) -> {
+            Iterator var2x = var0x.a().iterator();
+
+            while(var2x.hasNext()) {
+                MemoryModuleType<?> var22 = (MemoryModuleType)var2x.next();
+                this.memories.put(var22, Optional.empty());
+            }
+
+        });
+        Iterator<Entry<Dynamic<T>, Dynamic<T>>> var4 = var2.get("memories").asMap(Function.identity(), Function.identity()).entrySet().iterator();
+
+        while(var4.hasNext()) {
+            Entry<Dynamic<T>, Dynamic<T>> var44 = var4.next();
+            this.a(IRegistry.MEMORY_MODULE_TYPE.get(new MinecraftKey((var44.getKey()).asString(""))), var44.getValue());
+        }
+
+    }
+
+    public boolean hasMemory(MemoryModuleType<?> var0) {
+        return this.a(var0, MemoryStatus.VALUE_PRESENT);
+    }
+
+    private <T, U> void a(MemoryModuleType<U> var0, Dynamic<T> var1) {
+        this.setMemory(var0, (var0.getSerializer().orElseThrow(RuntimeException::new)).apply(var1));
+    }
+
+    public <U> void removeMemory(MemoryModuleType<U> var0) {
+        this.setMemory(var0, Optional.empty());
+    }
+
+    public <U> void setMemory(MemoryModuleType<U> var0, @Nullable U var1) {
+        this.setMemory(var0, Optional.ofNullable(var1));
+    }
+
+    public <U> void setMemory(MemoryModuleType<U> var0, Optional<U> var1) {
+        if (this.memories.containsKey(var0)) {
+            if (var1.isPresent() && this.a(var1.get())) {
+                this.removeMemory(var0);
+            } else {
+                this.memories.put(var0, var1);
+            }
+        }
+
+    }
+
+    public <U> Optional<U> getMemory(MemoryModuleType<U> var0) {
+        return (Optional)this.memories.get(var0);
+    }
+
+    public boolean a(MemoryModuleType<?> var0, MemoryStatus var1) {
+        Optional<?> var2 = (Optional)this.memories.get(var0);
+        if (var2 == null) {
+            return false;
+        } else {
+            return var1 == MemoryStatus.REGISTERED || var1 == MemoryStatus.VALUE_PRESENT && var2.isPresent() || var1 == MemoryStatus.VALUE_ABSENT && !var2.isPresent();
+        }
+    }
+
+    public Schedule getSchedule() {
+        return this.schedule;
+    }
+
+    public void setSchedule(Schedule var0) {
+        this.schedule = var0;
+    }
+
+    public void a(Set<Activity> var0) {
+        this.f = var0;
+    }
+
+    @Deprecated
+    public Stream<Behavior<? super E>> d() {
+        return this.c.values().stream().flatMap((var0) -> {
+            return var0.values().stream();
+        }).flatMap(Collection::stream).filter((var0) -> {
+            return var0.a() == Status.RUNNING;
+        });
+    }
+
+    public void a(Activity var0) {
+        this.g.clear();
+        this.g.addAll(this.f);
+        boolean var1 = this.e.keySet().contains(var0) && this.d(var0);
+        this.g.add(var1 ? var0 : this.h);
+    }
+
+    public void a(long var0, long var2) {
+        if (var2 - this.i > 20L) {
+            this.i = var2;
+            Activity var4 = this.getSchedule().a((int)(var0 % 24000L));
+            if (!this.g.contains(var4)) {
+                this.a(var4);
+            }
+        }
+
+    }
+
+    public void b(Activity var0) {
+        this.h = var0;
+    }
+
+    public void a(Activity var0, ImmutableList<Pair<Integer, ? extends Behavior<? super E>>> var1) {
+        this.a((Activity)var0, (ImmutableList)var1, (Set)ImmutableSet.of());
+    }
+
+    public void a(Activity var0, ImmutableList<Pair<Integer, ? extends Behavior<? super E>>> var1, Set<Pair<MemoryModuleType<?>, MemoryStatus>> var2) {
+        this.e.put(var0, var2);
+        var1.forEach((var1x) -> {
+            ((Set)((Map)this.c.computeIfAbsent(var1x.getFirst(), (var0x) -> {
+                return Maps.newHashMap();
+            })).computeIfAbsent(var0, (var0x) -> {
+                return Sets.newLinkedHashSet();
+            })).add(var1x.getSecond());
+        });
+    }
+
+    public boolean c(Activity var0) {
+        return this.g.contains(var0);
+    }
+
+    public BehaviorController<E> f() {
+        BehaviorController<E> var0 = new BehaviorController(this.memories.keySet(), this.sensors.keySet(), new Dynamic(DynamicOpsNBT.a, new NBTTagCompound()));
+        this.memories.forEach((var1, var2) -> {
+            var2.ifPresent((var2x) -> {
+                Optional var10000 = (Optional)var0.memories.put(var1, Optional.of(var2x));
+            });
+        });
+        return var0;
+    }
+
+    public void a(WorldServer var0, E var1) {
+        this.c(var0, var1);
+        this.d(var0, var1);
+        this.e(var0, var1);
+    }
+
+    public void b(WorldServer var0, E var1) {
+        long var2 = var1.world.getTime();
+        this.d().forEach((var4) -> {
+            var4.e(var0, var1, var2);
+        });
+    }
+
+    public <T> T a(DynamicOps<T> var0) {
+        T var1 = var0.createMap(this.memories.entrySet().stream().filter((var0x) -> {
+            return ((MemoryModuleType)var0x.getKey()).getSerializer().isPresent() && ((Optional)var0x.getValue()).isPresent();
+        }).map((var1x) -> {
+            return Pair.of(var0.createString(IRegistry.MEMORY_MODULE_TYPE.getKey(var1x.getKey()).toString()), ((MinecraftSerializable)((Optional)var1x.getValue()).get()).a(var0));
+        }).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond)));
+        return var0.createMap(ImmutableMap.of(var0.createString("memories"), var1));
+    }
+
+    private void c(WorldServer var0, E var1) {
+        this.sensors.values().forEach((var2) -> {
+            var2.b(var0, var1);
+        });
+    }
+
+    private void d(WorldServer var0, E var1) {
+        long var2 = var0.getTime();
+        this.c.values().stream().flatMap((var0x) -> {
+            return var0x.entrySet().stream();
+        }).filter((var0x) -> {
+            return this.g.contains(var0x.getKey());
+        }).map(Entry::getValue).flatMap(Collection::stream).filter((var0x) -> {
+            return var0x.a() == Status.STOPPED;
+        }).forEach((var4) -> {
+            var4.b(var0, var1, var2);
+        });
+    }
+
+    private void e(WorldServer var0, E var1) {
+        long var2 = var0.getTime();
+        this.d().forEach((var4) -> {
+            var4.c(var0, var1, var2);
+        });
+    }
+
+    private boolean d(Activity var0) {
+        return (this.e.get(var0)).stream().allMatch((var0x) -> {
+            MemoryModuleType<?> var1 = (MemoryModuleType)var0x.getFirst();
+            MemoryStatus var2 = (MemoryStatus)var0x.getSecond();
+            return this.a(var1, var2);
+        });
+    }
+
+    private boolean a(Object var0) {
+        return var0 instanceof Collection && ((Collection)var0).isEmpty();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BehaviorFindPosition.java b/src/main/java/net/minecraft/server/BehaviorFindPosition.java
new file mode 100644
index 000000000..2fa0c062a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BehaviorFindPosition.java
@@ -0,0 +1,66 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableMap;
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import net.minecraft.server.VillagePlace.Occupancy;
+
+public class BehaviorFindPosition extends Behavior<EntityCreature> {
+    private final VillagePlaceType a;
+    private final MemoryModuleType<GlobalPos> b;
+    private final boolean c;
+    private long d;
+    private final Long2LongMap e = new Long2LongOpenHashMap();
+    private int f;
+
+    public BehaviorFindPosition(VillagePlaceType var0, MemoryModuleType<GlobalPos> var1, boolean var2) {
+        super(ImmutableMap.of(var1, MemoryStatus.VALUE_ABSENT));
+        this.a = var0;
+        this.b = var1;
+        this.c = var2;
+    }
+
+    protected boolean a(WorldServer var0, EntityCreature var1) {
+        if (this.c && var1.isBaby()) {
+            return false;
+        } else {
+            return var0.getTime() - this.d >= 20L;
+        }
+    }
+
+    protected void a(WorldServer var0, EntityCreature var1, long var2) {
+        this.f = 0;
+        this.d = var0.getTime() + (long)var0.getRandom().nextInt(100);
+        VillagePlace var4 = var0.B();
+        Predicate<BlockPosition> var5 = (var0x) -> {
+            long var11 = var0x.asLong();
+            if (this.e.containsKey(var11)) {
+                return false;
+            } else if (++this.f >= 5) {
+                return false;
+            } else {
+                this.e.put(var11, this.d + 120L);
+                return true;
+            }
+        };
+        Stream<BlockPosition> var6 = var4.a(this.a.c(), var5, new BlockPosition(var1), 48, Occupancy.HAS_SPACE);
+        PathEntity var7 = var1.getNavigation().a(var6, this.a.d());
+        if (var7 != null && var7.h()) {
+            BlockPosition var8 = var7.k();
+            var4.c(var8).ifPresent((var4x) -> {
+                var4.a(this.a.c(), (var1x) -> {
+                    return var1x.equals(var8);
+                }, var8, 1);
+                var1.getBehaviorController().setMemory(this.b, GlobalPos.create(var0.getWorldProvider().getDimensionManager(), var8));
+                PacketDebug.c(var0, var8);
+            });
+        } else if (this.f < 5) {
+            this.e.long2LongEntrySet().removeIf((var0x) -> {
+                return var0x.getLongValue() < this.d;
+            });
+        }
+
+    }
+}
-- 
2.11.0

